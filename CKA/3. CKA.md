### Features of Kubernetes

- High-availability (HA), No DownTime
- Service Discovery and Load Balancing
- Storage Orchestration
- Self-Healing
- Secret and Configuration Management
- Horizontal Scaling
- Backup and Restore
- Rollbacks and Rollouts
- Automatic Bin Packing

**Orchestration**  - Container Orchestration tool or engine automates Deployment, Scaling, Scheduling, Load Balancing and Manage Containerized Application on a group of servers.


### Kubernetes Architecture
<img width="975" height="570" alt="image" src="https://github.com/user-attachments/assets/cf4660bc-9706-4169-81e9-8c1a4330ac4b" />

**Kubectl** - kubectl is the command-line interface (CLI) tool for interacting with a Kubernetes cluster. It serves as the primary interface for users to manage and control Kubernetes resource

**API Server** - The Kubernetes API server is a central component of the Kubernetes control plane, acting as the front-end for the entire cluster. It exposes the Kubernetes API, which is a RESTful API used to manage, create, and configure Kubernetes clusters and their resources.

**Scheduler** - 

**Controller Manager** - It’s the automation brain. Continuously checks what’s running vs. what should be running.

Example:If a Pod crashes and you asked for 3 Pods — Controller Manager says, “Hey! Only 2 Pods are alive. Let’s make one more.”

**etcd** - A key-value database that stores everything about your cluster. It’s like Kubernetes’ memory or hard drive.

**kubelet** - The Kubelet is the primary "node agent" that runs on each worker node within a Kubernetes cluster.

**kube-proxy** - Handles networking for Pods. It makes sure Pods can talk to each other and to the outside world. 
It sets up:
- Load balancing
- Port forwarding
- Cluster networking rules

**kubeadm** - Kubeadm is like the installation wizard for Kubernetes — a command-line tool that helps you bootstrap (set up) a production-grade Kubernetes cluster quickly and correctly.

**Pod** - A Pod in Kubernetes is the smallest deployable unit.

A Pod is a logical wrapper around one or more containers that share:
- Network (same IP address and port space)
- Storage (shared volumes)
- Context (metadata, configs, secrets)

### Background Study 
By default, container storage is ephemeral, meaning the data is lost when the container is stopped or deleted. So we need persistent storage.

### Installation 

| VMName | Name | master1 | IP | GW | DNS |
| --- | ---- | ---- | ---- | ---- | ---- | 
k8smaster1 | master1 | 192.168.10.100 | 192.168.10.1 | 8.8.8.8 |
k8sworker1 | worker1 | 192.168.10.101 | 192.168.10.1 | 8.8.8.8 |
k8sworker2 | worker2 | 192.168.10.102 | 192.168.10.1 | 8.8.8.8 |

### k8smaster1:
- Docker Engine
- kubeadm + kubectl + kubeadm
vi /etc/hosts
```bash
192.168.10.100  master1
192.168.10.101  worker1
192.168.10.102  worker2
```

### worker:
- Docker Engine
- kubeadm 
vi /etc/hosts
```bash
192.168.10.100  master1
192.168.10.101  worker1
192.168.10.102  worker2
```


