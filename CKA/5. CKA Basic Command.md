
### Viewing Resources:
`kubectl get nodes`: Lists all nodes in the cluster. <br>
`kubectl get nodes master1`
`kubectl get nodes -w`:  <br>
`kubectl get nodes -o wide`:  <br>
`kubectl get nodes -0 json`:   <br>
`kubectl get nodes -o yaml`:  <br>
`kubectl get pods`: Lists all pods in the current namespace.  <br>

`kubectl describe nodes`: <br>
`kubectl describe pods`  <br>
`kubectl describe namespace`  <br>
`kubectl describe nodes master1`: <br>
`kubectl get pods -A` <br>


kubectl run -h  <br>
kubectl run pod1 --image nginx  <br>
kubectl run web1 --image nginx --labels run=web1 <br>
kubectl run pod10 --image ubuntu  <br>
kubectl run --image ubuntu pod11 -- "sleep 100"  <br>
kubectl run pod1 --image nginx --namespace ns1  <br>
kubectl run pod1 --image nginx --dry-run=client  <br>
kubectl run pod1 --image nginx --dry-run=client -o yaml  <br>
kubectl create deployment dep1 --replicas 20 --image nginx <br>


kubectl describe pod pod7  <br>

kubectl delete pod pod1  <br>
kubectl delete pods --all  # delete all pod from current namespace; by default default namespace  <br>
kubectl delete pods --all -n kube-system #   <br>
kubectl delete pods --all -n ns1  <br>


kubectl logs pod/pod1  <br>


### Objects In Kubernetes
```bash
kubectl api-resources
```

### Namespace 
In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc.) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc.).
```bash
kubectl explain namespace
kubectl get namespaces/ns
```
Create/Delete Namespace
```bash
kubectl create ns prod1
kubectl describe ns prod1
kubectl delete ns prod1
```


### Pod Run using yml file 
```bash
kubectl explain pod
```

#### sigle pod
```yml
---
apiVersion: v1
kind: Pod
metadata:
  name: singlepod
spec:
  containers:
    - name: container1
      image: httpd
```
```bash
kubectl apply -f singlepod.yaml --dry-run=client
kubectl apply -f singlepod.yaml
```
```bash
kubectl exec -it pods/singlepod -- /bin/bash
```

#### Multiple container
```bash
---
apiVersion: v1
kind: Pod
metadata:
  name: multiplecontainer
spec:
 containers:
   - name: doc1
     image: nginx
   - name: doc2
     image: redis
```
```bash
kubectl apply -f multicontainer.yaml --dry-run=client
kubectl apply -f multicontainer.yaml
```
```bash
 kubectl exec -it pods/multiplecontainer11 -c doc1 -- /bin/bash
 kubectl exec -it pods/multiplecontainer11 -c doc2 -- /bin/bash
```



### Taint
Trun off worker node

create pod
```bash
kubectl run pod1 --image nginx  # it will be in pending state
```

check
```bash
kubectl describe nodes master1 | grep -i taint
```
untaint
```bash
kubectl taint node master1 node-role.kubernetes.io/control-plane:NoSchedule-
```
After untaint the pod will run in master node


### Troubleshooting
```bash
kubectl create deployment dep1 --image nginx --replicas 10
kubectl get pods -o wide
kubectl get pods -o wide | grep -i worker1
```
we will see multiple pods will be restarted

To prevent pod restart 
```bash
cd /etc/default
vi kubelet

 KUBELET_EXTRA_ARGS="--cgroup-driver=cgroupfs"

systemctl daemon-reload
systemctl restart kubelet.service
```
pod gulo ke CPU Memory allocation kore systemd & cgroup. We will fix this to cgroup.
```bash
kubectl delete deployments dep1
```


### Edit Pod

Remember, we CANNOT edit specifications of an existing POD other than the below.
- `spec.containers[*].image`
- `spec.initContainers[*].image`
- `spec.activeDeadlineSeconds`
- `spec.tolerations`

#### Edit Name
```bash
kubectl run pod1 --image nginx
kubectl edit pods pod1
  name: pod10  # change name pod1  >pod10
```

An Yaml file named pod10 created in /tmp
<img width="719" height="62" alt="image" src="https://github.com/user-attachments/assets/8cebab60-5e6b-4173-ba84-0c16e174441f" />

We can run this file from /tmp
```bash
kubectl apply -f /tmp/kubectl-edit-1644418017.yaml
kubectl get pods
```

#### Edit Image
```bash
kubectl edit pods pod1
  image: httpd   #change image nginx to httpd 
```

#### Add Container in existing pod; Rule:1
```bash
kubectl edit pods pod1
  # Add this line
  - name: redis
    image: redis
```
<img width="723" height="239" alt="image" src="https://github.com/user-attachments/assets/e5fa4775-c7a5-4de2-9697-7d2fb8a3742c" />

```bash
kubectl delete pod pod1
kubectl apply -f /tmp/kubectl-edit-1602094205.yaml
kubectl describe pods pod1 | grep -i image
```


### Add Container in existing pod; Rule:2
```bash
kubectl set image pods/pod1 pod1=nginx   # here pod1=nginx; pod1 is container name
kubectl set image pods/pod1 redis=httpd
kubectl describe pods pod1
```


### Kubectl apply/create/replace
```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
    - name: doc1
      image: nginx
```
```bash
kubectl apply -f pod1.yaml --dry-run=client
```

create is for newly resource, if exist it will warning
```bash
kubectl create -f pod1.yaml
```

If same resource exist, it will update the resource
```bash
kubectl apply -f pod1.yaml
```

If i change the name doc1 to doc2
```bash
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
    - name: doc2
      image: nginx
```
```bash
kubectl replace -f pod1.yaml --force
kubectl describe pod pod1
```


### Execute command in container of a pod or get a shell of container

```bash
kubectl exec pods/<podname> -- <command>
kubectl exec pods/pod1 -- date
kubectl exec pods/pod1 -- hostname

kubectl exec -it pods/<podname> -- <command>
kubectl exec -it pods/pod1 -- /bin/bash
```

If pod have multiple container
```bash
kubectl describe pod pod1
kubectl exec pods/<podname> -c <containername> -- <command>
```

### Copy from host to pod
Create a file name index.html in master ndoe and write `welcome to CKA`

```bash
kubectl get pods -o wide
kubectl cp index.html pod1:/usr/share/nginx/html
curl <pod ip>
kubectl exec pods/pod1 -- ls -l /usr/share/nginx/html/index.html


for multiple container
kubectl cp index.html pod1:/usr/share/nginx/html -c <containername>
kubectl cp index.html pod1:/usr/share/nginx/html -c doc1

```

### Copy from container to node

```bash
kubectl cp pod1:/usr/share/nginx/html ./
```

for multiple container
```bash
kubectl describe pod pod1  # find the container name
kubectl cp pod1:/usr/share/nginx/html -c <containername> ./
kubectl cp pod1:/usr/share/nginx/html -c doc1 ./

```


### Copy directory from host to pod
```bash
kubectl cp dhaka/ pod1:/tmp
kubectl exec pod1 -- ls -l /tmp
kubectl exec pod1 -- ls -l /tmp/dhaka
```

### Logs

```bash
kubectl logs <podname>
kubectl logs/<podname>
kubectl logs pod1

kubectl logs <podname> -c <containername>
kubectl logs pod1 -c doc1

kubectl logs pods/pod1 -c doc1 --since=1h
kubectl logs pods/pod1 -c doc1 --tail=10

kubectl logs pods/pod1 -c doc1 --follow
#curl from worker node
```

### SideCar Container
Sidecar containers are the secondary containers that run along with the main application container within the same Pod.

A sidecar container can collect logs generated by the primary containers and forward them to a centralized logging system.

It can also capture metrics and monitoring data from the primary containers and send them to a monitoring system or dashboard.



### initContainer
specialized containers that run before app containers in a Pod.

Init containers can contain utilities or setup scripts not present in an app image. You can specify init containers in the Pod specification alongside the containers array (which describes app containers).
<img width="794" height="589" alt="image" src="https://github.com/user-attachments/assets/730ab349-7c52-470e-a1af-4d653b812f8c" />

```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
    - name: container1
      image: nginx
  initContainers:
    - name: container2
      image: ubuntu
```
```bash
kubectl apply -f initContainer.yaml
kubectl describe pod pod1 | more
```


### Pod Restart Policy
- Never (never restart)
- Always (by default)
- OnFailure (If fail, then restart)

#### Never
```bash
kubectl run never --image ubuntu --restart Never
```

#### Always
```bash
kubectl run always --image ubuntu
```

Example: it will restart after 10 sec
```bash
kubectl run ubuntu --image ubuntu -- sleep 10
kubectl get pods -w
```

#### OnFailure
```bash
kubectl run onfailure --image ubuntu --restart OnFailure
```
jodi akta poder moddhe dui ta container thake, and akta container e jodi issue hoi taile sudhu sei container restart hobe. onno container restarrt hobe na

<img width="617" height="122" alt="image" src="https://github.com/user-attachments/assets/670e7843-e058-4ed7-8414-40312c61dd58" />




