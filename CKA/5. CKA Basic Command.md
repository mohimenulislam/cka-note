
### Viewing Resources:
`kubectl get nodes`: Lists all nodes in the cluster. <br>
`kubectl get nodes master1`
`kubectl get nodes -w`:  <br>
`kubectl get nodes -o wide`:  <br>
`kubectl get nodes -0 json`:   <br>
`kubectl get nodes -o yaml`:  <br>
`kubectl get pods`: Lists all pods in the current namespace.  <br>

`kubectl describe nodes`: <br>
`kubectl describe pods`  <br>
`kubectl describe namespace`  <br>
`kubectl describe nodes master1`: <br>
`kubectl get pods -A` <br>


kubectl run -h  <br>
kubectl run pod1 --image nginx  <br>
kubectl run pod10 --image ubuntu  <br>
kubectl run --image ubuntu pod11 -- "sleep 100"  <br>
kubectl run pod1 --image nginx --namespace ns1  <br>
kubectl run pod1 --image nginx --dry-run=client  <br>
kubectl run pod1 --image nginx --dry-run=client -o yaml  <br>
kubectl create deployment dep1 --replicas 20 --image nginx <br>


kubectl describe pod pod7  <br>

kubectl delete pod pod1  <br>
kubectl delete pods --all  # delete all pod from current namespace; by default default namespace  <br>
kubectl delete pods --all -n kube-system #   <br>
kubectl delete pods --all -n ns1  <br>


kubectl logs pod/pod1  <br>


### Objects In Kubernetes
```bash
kubectl api-resources
```

### Namespace 
In Kubernetes, namespaces provide a mechanism for isolating groups of resources within a single cluster. Names of resources need to be unique within a namespace, but not across namespaces. Namespace-based scoping is applicable only for namespaced objects (e.g. Deployments, Services, etc.) and not for cluster-wide objects (e.g. StorageClass, Nodes, PersistentVolumes, etc.).
```bash
kubectl explain namespace
kubectl get namespaces/ns
```
Create/Delete Namespace
```bash
kubectl create ns prod1
kubectl describe ns prod1
kubectl delete ns prod1
```


### Pod Run using yml file 
```bash
kubectl explain pod
```

#### sigle pod
```yml
---
apiVersion: v1
kind: Pod
metadata:
  name: singlepod
spec:
  containers:
    - name: container1
      image: httpd
```
```bash
kubectl apply -f singlepod.yaml --dry-run=client
kubectl apply -f singlepod.yaml
```
```bash
kubectl exec -it pods/singlepod -- /bin/bash
```

#### Multiple container
```bash
---
apiVersion: v1
kind: Pod
metadata:
  name: multiplecontainer
spec:
 containers:
   - name: doc1
     image: nginx
   - name: doc2
     image: redis
```
```bash
kubectl apply -f multicontainer.yaml --dry-run=client
kubectl apply -f multicontainer.yaml
```
```bash
 kubectl exec -it pods/multiplecontainer11 -c doc1 -- /bin/bash
 kubectl exec -it pods/multiplecontainer11 -c doc2 -- /bin/bash
```



### Taint
Trun off worker node

create pod
```bash
kubectl run pod1 --image nginx  # it will be in pending state
```

check
```bash
kubectl describe nodes master1 | grep -i taint
```
untaint
```bash
kubectl taint node master1 node-role.kubernetes.io/control-plane:NoSchedule-
```
After untaint the pod will run in master node


### Troubleshooting
```bash
kubectl create deployment dep1 --image nginx --replicas 10
kubectl get pods -o wide
kubectl get pods -o wide | grep -i worker1
```
we will see multiple pods will be restarted

To prevent pod restart 
```bash
cd /etc/default
vi kubelet

 KUBELET_EXTRA_ARGS="--cgroup-driver=cgroupfs"

systemctl daemon-reload
systemctl restart kubelet.service
```
pod gulo ke CPU Memory allocation kore systemd & cgroup. We will fix this to cgroup.
```bash
kubectl delete deployments dep1
```


### Edit Pod

Remember, we CANNOT edit specifications of an existing POD other than the below.
- `spec.containers[*].image`
- `spec.initContainers[*].image`
- `spec.activeDeadlineSeconds`
- `spec.tolerations`

#### Edit Name
```bash
kubectl run pod1 --image nginx
kubectl edit pods pod1
  name: pod10  # change name pod1  >pod10
```

An Yaml file named pod10 created in /tmp
<img width="719" height="62" alt="image" src="https://github.com/user-attachments/assets/8cebab60-5e6b-4173-ba84-0c16e174441f" />

We can run this file from /tmp
```bash
kubectl apply -f /tmp/kubectl-edit-1644418017.yaml
kubectl get pods
```

#### Edit Image
```bash
kubectl edit pods pod1
  image: httpd   #change image nginx to httpd 
```

#### Add Container in existing pod; Rule:1
```bash
kubectl edit pods pod1
  # Add this line
  - name: redis
    image: redis
```
<img width="723" height="239" alt="image" src="https://github.com/user-attachments/assets/e5fa4775-c7a5-4de2-9697-7d2fb8a3742c" />

```bash
kubectl delete pod pod1
kubectl apply -f /tmp/kubectl-edit-1602094205.yaml
kubectl describe pods pod1 | grep -i image
```


### Add Container in existing pod; Rule:2
```bash
kubectl set image pods/pod1 pod1=nginx   # here pod1=nginx; pod1 is container name
kubectl set image pods/pod1 redis=httpd
kubectl describe pods pod1
```


### Kubectl apply/create/replace
```yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
    - name: doc1
      image: nginx
```
```bash
kubectl apply -f pod1.yaml --dry-run=client
```

create is for newly resource, if exist it will warning
```bash
kubectl create -f pod1.yaml
```

If same resource exist, it will update the resource
```bash
kubectl apply -f pod1.yaml
```

If i change the name doc1 to doc2
```bash
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
    - name: doc2
      image: nginx
```
```bash
kubectl replace -f pod1.yaml --force
kubectl describe pod pod1
```


### Execute command in container of a pod or get a shell of container

```bash
kubectl exec pods/<podname> -- <command>
kubectl exec pods/pod1 -- date
kubectl exec pods/pod1 -- hostname

kubectl exec -it pods/<podname> -- <command>
kubectl exec -it pods/pod1 -- /bin/bash
```

If pod have multiple container
```bash
kubectl describe pod pod1
kubectl exec pods/<podname> -c <containername> -- <command>
```

### Copy from host to pod
Create a file name index.html in master ndoe and write `welcome to CKA`

```bash
kubectl get pods -o wide
kubectl cp index.html pod1:/usr/share/nginx/html
curl <pod ip>
kubectl exec pods/pod1 -- ls -l /usr/share/nginx/html/index.html


for multiple container
kubectl cp index.html pod1:/usr/share/nginx/html -c <containername>
kubectl cp index.html pod1:/usr/share/nginx/html -c doc1

```

### Copy from container to node

```bash
kubectl cp pod1:/usr/share/nginx/html ./
```

for multiple container
```bash
kubectl describe pod pod1  # find the container name
kubectl cp pod1:/usr/share/nginx/html -c <containername> ./
kubectl cp pod1:/usr/share/nginx/html -c doc1 ./

```


### Copy directory from host to pod
```bash
kubectl cp dhaka/ pod1:/tmp
kubectl exec pod1 -- ls -l /tmp
kubectl exec pod1 -- ls -l /tmp/dhaka
```

### Logs

```bash
kubectl logs <podname>
kubectl logs/<podname>
kubectl logs pod1

kubectl logs <podname> -c <containername>
kubectl logs pod1 -c doc1

kubectl logs pods/pod1 -c doc1 --since=1h
kubectl logs pods/pod1 -c doc1 --tail=10

kubectl logs pods/pod1 -c doc1 --follow
#curl from worker node
```
