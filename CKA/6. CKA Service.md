
### Kubernetes service
In Kubernetes, a Service is a method for exposing a network application that is running as one or more Pods in your cluster.

Since pods are ephemeral, a service enables a group of pods, which provide specific functions (web services, image processing, etc.) to be assigned a name and unique IP address (clusterIP). As long as the service is running that IP address, it will not change. Services also define policies for their access. 

#### Types of service
- ClusterIP
- NodePort
- Loadbalancer
- ExternalName

#### ClusterIP
The ClusterIP provides a load-balanced IP address. One or more pods that match a label `selector`   can forward traffic to the IP address. The ClusterIP service must define one or more ports to listen on with target ports to forward TCP/UDP traffic to containers.

ClusterIP Services allow internal connectivity between different applications within the cluster, providing a stable IP address for communication.

- Use case: Internal communication inside the cluster.
- Example: Your backend app talks to the database using an internal address.

**From service file it check its selector not labels. From pod side its check labels**
  
<img width="851" height="559" alt="image" src="https://github.com/user-attachments/assets/b11763a9-151d-4bd8-95ed-ff6f8158ddff" />

<img width="945" height="497" alt="image" src="https://github.com/user-attachments/assets/84b9748e-1004-4fc2-aeba-1dd89b530bda" />

```bash
kubectl run webapp1 --image nginx
kubectl get pods -o wide

vi index.html
  webapp1

kubectl cp index.html webapp:/usr/share/nginx/html
curl <podIP>
```

```bash
kubectl get service
```

- nodeport: externaly listen
- port: service koto number port a listen korbe
- targetpor: container er koto number port e jabe

```bash
kubectl create service clusterip svc1 --tcp 80
# service port 80 & target port 80


#Check labels
kubectl get service
kubectl get service svc1 --show-labels
kubectl describe service svc1
kubectl get pod webapp --show-labels
# Here we have to keep same both service labels and pod labels.
# We can change service labels as well pod labels also
# If we edit the service we will change the silector
```

Labels change
```bash
kubectl edit pod webapp1  #same as service labels
  app: svc1

kubectl get pod webapp1 --show-labels

# Or
kubectl label pod webapp1 app=svc1    # if not work try below
kubectl label pod webapp1 app=svc1 --overwrite


curl <serviceIP>
```
<img width="484" height="211" alt="image" src="https://github.com/user-attachments/assets/64d73de1-460b-4594-ac0d-257cade34ecc" />


We can run another webapp and change the label. We will see the service is working like loadbalancer
```bash
kubectl run webapp2 --image nginx

vi index.html
  webapp2

kubectl cp index.html webapp2:/usr/share/nginx/html

kubectl edit pod webapp2  #same as service labels
  app: svc1

kubectl get pod webapp2 --show-labels

curl <serviceIP>
```
We can see webapp1 and webapp2

Here we manually set the IP and 81 is service IP, 80 is container IP 
```bash
kubectl delete service svc1
kubectl create service clusterip svc1 --clusterip 10.106.234.80 --tcp 81:80
# service er 81 port e request asle container er 80 port e jabe

curl 10.106.234.80:81
```

It will create service first then pod
```bash
kubectl run pod1 --image nginx --port 80 --expose
curl <serviceIP>
```

Edit service
```bash
kubectl edit service svc1
```


#### Another Example of Service

service2:80 >> Container:80    <br>
Service2:81 >> Container:80 

Create new service name svc2
```bash
kubectl create service clusterip svc2 --tcp 80 -o yaml --dry-run=client
kubectl create service clusterip svc2 --tcp 80
kubectl get service
```

Edit Service, We want to listen service port 80 & 81
```bash
# add this line under port
  - name: "port2"
    port: 81
    protocol: TCP
    targetPort: 80
```
<img width="894" height="239" alt="image" src="https://github.com/user-attachments/assets/f6346b9a-23cb-4051-822c-2279ddb0a351" />


Create pod with label
```bash
kubectl run webapp1 --image nginx --labels app=svc2
kubectl run webapp2 --image nginx --labels app=svc2

#check label
kubectl get pod  --show-labels
```

Edit html page
```bash
vi index.html
  webapp1
kubectl cp index.html webapp1:/usr/share/nginx/html


vi index.html
  webapp2
kubectl cp index.html webapp2:/usr/share/nginx/html
```

Curl
```bash
curl <serviceIP>
curl <serviceIP>:81
```
Both pod are listen from 80 & 81


#### NodePort
NodePort builds on top of the ClusterIP Service and provides a way to expose a group of Pods to the outside world. At the API level, the only difference from the ClusterIP is the mandatory service type which has to be set to NodePort; the rest of the values can remain the same.

ClusterIP Services allow internal connectivity between different applications within the cluster, providing a stable IP address for communication.

- Use case: Access the app from outside the cluster (like your browser).
- Explanation: Kubernetes opens a specific port (like 30007) on every worker node, forwarding requests to your app inside the cluster.

<img width="765" height="435" alt="image" src="https://github.com/user-attachments/assets/652863a6-a364-485c-89f8-9a3bc136790f" />

Nodeport range 30000 to 32767

```bash
kubectl create service nodeport ndp1 --tcp 80 -o yaml --dry-run=client    # if node port not define it will take autometically
kubectl create service nodeport ndp1 --tcp 80 --node-port 30100 -o yaml --dry-run=client

kubectl create service nodeport ndp1 --tcp 80 --node-port 30100
kubectl get service ndp1 --show-labels

#Pod create
kubectl run web1 --image nginx --labels app=ndp1

# check from browser
http://192.168.10.100:30100/  # masternode ip
```

Rules: nodeport>>port>>targetport  30200:80:80


#### Loadbalancer
he LoadBalancer service type is built on top of NodePort service types by provisioning and configuring external load balancers from public and private cloud providers. It exposes services that are running in the cluster by forwarding layer 4 traffic to worker nodes. This is a dynamic way of implementing a case that involves external load balancers and NodePort type services.

LoadBalancer service is specially for cloud platforms.

- Use case: Used in cloud environments (AWS, GCP, Azure) to get a public IP.
- Explanation: It automatically creates a cloud load balancer that distributes external traffic across Pods.

<img width="839" height="506" alt="image" src="https://github.com/user-attachments/assets/d6225f8b-7260-4772-8920-df676793cb28" />


#### ExternalName
The ExternalName service in Kubernetes is a specialized type of Service that allows you to map an in-cluster service name to an external hostname or IP address outside of your Kubernetes cluster. This feature enables seamless integration between your Kubernetes applications and external services or resources, providing a bridge between your containerized workloads and the external environment.

The ExternalName service is particularly useful in scenarios where you need to access services hosted outside your Kubernetes cluster, migrate legacy applications to Kubernetes while maintaining dependencies on external systems, or create hybrid deployments where some components run in Kubernetes while others run on external systems. By mapping an internal service name to an external resource, you can transparently access external services from within your Kubernetes applications, simplifying the integration process and enabling a smoother transition to a containerized environment.

- Use case: Connect your app to an external service (like a database hosted elsewhere).
- Explanation: It maps a Kubernetes Service name to an external DNS name (like api.external.com).

 Kichu service kubernetes cluster a cholte pare abar database physical host e cholte pare

<img width="636" height="313" alt="image" src="https://github.com/user-attachments/assets/633b56f2-a1e1-4412-bffa-55bfa2bef39e" />

ExternalName have no load balancer


```bash
kubectl create service externalname ext1 --external-name 192.168.10.152 --tcp 80
```
